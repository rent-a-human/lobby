<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Lobby</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }

        #block-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            pointer-events: none;
            display: none;
        }

        #server-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 15px 20px;
            border-radius: 5px;
            border: 2px solid #555;
            pointer-events: none;
        }

        #server-info h2 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #55ff55;
        }

        #server-info p {
            font-size: 14px;
            margin: 5px 0;
        }

        .status-online {
            color: #55ff55;
        }

        .status-offline {
            color: #ff5555;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 15px 20px;
            border-radius: 5px;
            border: 2px solid #555;
            pointer-events: none;
        }

        #controls p {
            font-size: 12px;
            margin: 3px 0;
        }

        #coordinates {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #aaa;
            padding: 10px 15px;
            border-radius: 5px;
            border: 2px solid #555;
            font-size: 11px;
            pointer-events: none;
            font-family: 'Courier New', monospace;
        }

        #coordinates p {
            margin: 2px 0;
        }

        #hotbar {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #555;
            pointer-events: none;
        }

        .hotbar-slot {
            width: 50px;
            height: 50px;
            border: 3px solid #555;
            background: rgba(139, 139, 139, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #fff;
            font-weight: bold;
            position: relative;
            border-radius: 4px;
        }

        .hotbar-slot.active {
            border-color: #fff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .hotbar-slot .key-hint {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 9px;
            color: #ccc;
        }

        .hotbar-slot .block-preview {
            width: 30px;
            height: 30px;
            border-radius: 2px;
        }

        #interaction-prompt {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform: translate(-50%, 50px);
            background: rgba(0, 0, 0, 0.8);
            color: #ffff55;
            padding: 10px 20px;
            border-radius: 5px;
            border: 2px solid #ffff55;
            font-size: 14px;
            display: none;
            pointer-events: none;
        }

        #click-to-start {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 30px 50px;
            border-radius: 10px;
            border: 3px solid #55ff55;
            font-size: 20px;
            cursor: pointer;
            pointer-events: all;
            text-align: center;
        }

        #click-to-start:hover {
            background: rgba(0, 100, 0, 0.9);
        }

        #save-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #55ff55;
            padding: 10px 15px;
            border-radius: 5px;
            border: 2px solid #555;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #save-indicator.show {
            opacity: 1;
        }

        #debug-log {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            font-family: monospace;
            font-size: 10px;
            padding: 10px;
            overflow-y: auto;
            border: 1px solid #333;
            pointer-events: none;
            display: flex;
            flex-direction: column-reverse;
            /* Newest at bottom visually if we append? No, usually top. Let's stick to standard. */
            z-index: 1000;
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none;
            /* Hidden by default, shown via JS if touch detected */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2000;
        }

        #joystick-zone {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }

        #joystick-base {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }

        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transition: transform 0.1s;
        }

        #mobile-actions {
            position: absolute;
            bottom: 180px;
            /* Moved up to make room for right joystick */
            right: 30px;
            display: flex;
            gap: 20px;
            pointer-events: auto;
        }

        #look-joystick-zone {
            position: absolute;
            bottom: 50px;
            right: 50px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }

        #look-joystick-base {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }

        #look-joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transition: transform 0.1s;
        }

        .mobile-btn {
            width: 60px;
            /* Smaller buttons */
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            user-select: none;
            -webkit-user-select: none;
        }

        .mobile-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <div id="crosshair"></div>
        <div id="block-indicator"></div>

        <div id="server-info">
            <h2>‚ö° Lobby Server</h2>
            <p>Status: <span class="status-online">‚óè Connecting...</span></p>
            <p>Players: <span id="player-count">0/100</span></p>
            <p>Ping: <span id="ping">- ms</span></p>
            <p id="debug-mode-indicator" style="display:none; color: #ffff55; font-weight: bold; margin-top: 5px;">DEBUG
                MODE: ON</p>
        </div>

        <div id="debug-log"></div>

        <div id="save-indicator">
            üíæ Block Saved
        </div>

        <div id="controls">
            <p><strong>CONTROLS</strong></p>
            <p>WASD - Move</p>
            <p>SPACE - Jump</p>
            <p>MOUSE - Look Around</p>
            <p>LEFT CLICK - Place Block</p>
            <p>RIGHT CLICK - Remove Block</p>
            <p>T - Toggle Camera View</p>
            <p>E - Interact with Portal</p>
            <p>C - Clear All Blocks</p>
            <p>G - Toggle Debug Mode</p>
        </div>

        <div id="interaction-prompt">
            Press <strong>E</strong> to enter the server
        </div>

        <div id="save-indicator">
            üíæ Progress Saved
        </div>

        <div id="coordinates">
            <p>X: <span id="coord-x">0</span></p>
            <p>Y: <span id="coord-y">0</span></p>
            <p>Z: <span id="coord-z">0</span></p>
        </div>

        <div id="hotbar">
            <div class="hotbar-slot active" data-slot="0">
                <span class="key-hint">1</span>
                <div class="block-preview" style="background: #666;"></div>
            </div>
            <div class="hotbar-slot" data-slot="1">
                <span class="key-hint">2</span>
                <div class="block-preview" style="background: #8B4513;"></div>
            </div>
            <div class="hotbar-slot" data-slot="2">
                <span class="key-hint">3</span>
                <div class="block-preview" style="background: linear-gradient(#5d9f3e 0%, #5d9f3e 70%, #7a5a3a 70%);">
                </div>
            </div>
            <div class="hotbar-slot" data-slot="3">
                <span class="key-hint">4</span>
                <div class="block-preview" style="background: #DC143C;"></div>
            </div>
            <div class="hotbar-slot" data-slot="4">
                <span class="key-hint">5</span>
                <div class="block-preview" style="background: #FFD700;"></div>
            </div>
            <div class="hotbar-slot" data-slot="5">
                <span class="key-hint">6</span>
                <div class="block-preview" style="background: rgba(173, 216, 230, 0.7);"></div>
            </div>
            <div class="hotbar-slot" data-slot="6">
                <span class="key-hint">7</span>
                <div class="block-preview" style="background: #DEB887;"></div>
            </div>
            <div class="hotbar-slot" data-slot="7">
                <span class="key-hint">8</span>
                <div class="block-preview" style="background: #CD853F;"></div>
            </div>
            <div class="hotbar-slot" data-slot="8">
                <span class="key-hint">9</span>
                <div class="block-preview" style="background: #00CED1;"></div>
            </div>
            <div class="hotbar-slot" data-slot="9">
                <span class="key-hint">0</span>
                <div class="block-preview" style="background: #4B0082;"></div>
            </div>
        </div>

        <div id="click-to-start">
            <div>Enter Name & Start</div>
            <input type="text" id="player-name-input" placeholder="Enter your name"
                style="margin-top: 15px; padding: 10px; font-size: 16px; border-radius: 5px; border: none; text-align: center;">
            <div id="start-btn"
                style="margin-top: 15px; background: #55ff55; color: #000; padding: 10px 20px; border-radius: 5px; font-weight: bold; font-size: 16px;">
                JOIN GAME</div>
            <div id="join-error" style="color: #ff5555; font-size: 14px; margin-top: 10px; display: none;"></div>
            <div style="font-size: 14px; margin-top: 10px; opacity: 0.7;">Click to capture mouse after joining</div>
        </div>

        <div id="message-input-container"
            style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 20px; border: 2px solid #55ff55; border-radius: 10px; text-align: center; pointer-events: all;">
            <h3 style="color: #55ff55; margin-bottom: 10px;">Leave a Message</h3>
            <input type="text" id="message-input" maxlength="30" placeholder="Type your message..."
                style="padding: 10px; font-size: 16px; width: 250px;">
            <div style="margin-top: 10px; font-size: 12px; color: #aaa;">Press ENTER to send, ESC to cancel</div>
        </div>

        <div id="mobile-controls">
            <div id="joystick-zone">
                <div id="joystick-base"></div>
                <div id="joystick-knob"></div>
            </div>
            <div id="mobile-actions">
                <div id="jump-btn" class="mobile-btn">JUMP</div>
                <div id="action-btn" class="mobile-btn">PLACE</div>
            </div>
            <div id="look-joystick-zone">
                <div id="look-joystick-base"></div>
                <div id="look-joystick-knob"></div>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Use production URL if on GitHub Pages, otherwise localhost
        const BACKEND_URL = window.location.hostname.includes('github.io')
            ? 'https://lobby-backend-285d24d0f147.herokuapp.com' // Replace with your actual backend URL
            : 'https://lobby-backend-285d24d0f147.herokuapp.com';
        const socket = io(BACKEND_URL);

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 0, 150);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);

        // Materials
        const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x5d9f3e });
        const stoneMaterial = new THREE.MeshLambertMaterial({ color: 0x7a7a7a });
        const woodMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
        const glowMaterial = new THREE.MeshBasicMaterial({ color: 0x9d4edd });

        // Create textured stone material for player-placed blocks
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        // Function to create textured material
        function createBlockTexture(baseColor, variation = 30, spots = 200) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, 64, 64);

            for (let i = 0; i < spots; i++) {
                const x = Math.random() * 64;
                const y = Math.random() * 64;
                const size = Math.random() * 3 + 1;
                const shade = Math.random() * variation - variation / 2;

                const rgb = baseColor.match(/\d+/g);
                if (rgb) {
                    const r = Math.max(0, Math.min(255, parseInt(rgb[0]) + shade));
                    const g = Math.max(0, Math.min(255, parseInt(rgb[1]) + shade));
                    const b = Math.max(0, Math.min(255, parseInt(rgb[2]) + shade));
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x, y, size, size);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return new THREE.MeshLambertMaterial({ map: texture });
        }

        // Create grass block material (special case with top/side)
        function createGrassBlockMaterial() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Grass top
            ctx.fillStyle = '#5d9f3e';
            ctx.fillRect(0, 0, 64, 64);
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * 64;
                const y = Math.random() * 64;
                const shade = Math.random() * 40 - 20;
                ctx.fillStyle = `rgb(${93 + shade}, ${159 + shade}, ${62 + shade})`;
                ctx.fillRect(x, y, 2, 2);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return new THREE.MeshLambertMaterial({ map: texture });
        }

        // Block materials array
        const blockMaterials = [
            createBlockTexture('rgb(102, 102, 102)', 60, 200),  // 1: Stone (gray)
            createBlockTexture('rgb(139, 69, 19)', 40, 180),    // 2: Wood (brown)
            createGrassBlockMaterial(),                          // 3: Grass
            createBlockTexture('rgb(220, 20, 60)', 30, 150),    // 4: Red brick
            createBlockTexture('rgb(255, 215, 0)', 20, 100),    // 5: Gold
            new THREE.MeshLambertMaterial({                      // 6: Glass (transparent)
                color: 0xADD8E6,
                transparent: true,
                opacity: 0.6
            }),
            createBlockTexture('rgb(222, 184, 135)', 35, 160),  // 7: Sand
            createBlockTexture('rgb(205, 133, 63)', 45, 190),   // 8: Cobblestone
            createBlockTexture('rgb(0, 206, 209)', 25, 120),    // 9: Diamond
            createBlockTexture('rgb(75, 0, 130)', 20, 130)      // 0: Obsidian (purple/black)
        ];

        let selectedBlockType = 0; // Currently selected block (0-9)

        // Track player-placed blocks
        const placedBlocks = [];
        const blockSize = 2;

        // Update hotbar selection display
        function updateHotbarDisplay() {
            document.querySelectorAll('.hotbar-slot').forEach((slot, index) => {
                if (index === selectedBlockType) {
                    slot.classList.add('active');
                } else {
                    slot.classList.remove('active');
                }
            });
        }

        // Create player model
        function createPlayerModel() {
            const player = new THREE.Group();

            // Create skin texture (simple Steve-like skin)
            const skinCanvas = document.createElement('canvas');
            skinCanvas.width = 64;
            skinCanvas.height = 64;
            const skinCtx = skinCanvas.getContext('2d');

            // Skin color
            skinCtx.fillStyle = '#f0c896';
            skinCtx.fillRect(0, 0, 64, 64);

            // Add simple details
            skinCtx.fillStyle = '#3b5998'; // Blue shirt
            skinCtx.fillRect(16, 32, 32, 16);

            skinCtx.fillStyle = '#2c4a7c'; // Dark blue pants
            skinCtx.fillRect(16, 48, 32, 16);

            // Face details
            skinCtx.fillStyle = '#000';
            skinCtx.fillRect(12, 12, 4, 4); // Left eye
            skinCtx.fillRect(20, 12, 4, 4); // Right eye
            skinCtx.fillRect(16, 20, 8, 2); // Mouth

            const skinTexture = new THREE.CanvasTexture(skinCanvas);
            skinTexture.magFilter = THREE.NearestFilter;
            skinTexture.minFilter = THREE.NearestFilter;

            const skinMaterial = new THREE.MeshLambertMaterial({ map: skinTexture });
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x3b5998 });
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2c4a7c });

            // Head (8x8x8 units = 0.4x0.4x0.4 in our scale)
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.4, 0.4),
                skinMaterial
            );
            head.position.y = 0.9;
            head.castShadow = true;
            player.add(head);

            // Body (8x12x4 units)
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.6, 0.2),
                bodyMaterial
            );
            body.position.y = 0.4;
            body.castShadow = true;
            player.add(body);

            // Right arm
            const rightArm = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.6, 0.2),
                skinMaterial
            );
            rightArm.position.set(-0.3, 0.4, 0);
            rightArm.castShadow = true;
            player.add(rightArm);

            // Left arm
            const leftArm = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.6, 0.2),
                skinMaterial
            );
            leftArm.position.set(0.3, 0.4, 0);
            leftArm.castShadow = true;
            player.add(leftArm);

            // Right leg
            const rightLeg = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.6, 0.2),
                legMaterial
            );
            rightLeg.position.set(-0.1, -0.2, 0);
            rightLeg.castShadow = true;
            player.add(rightLeg);

            // Left leg
            const leftLeg = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.6, 0.2),
                legMaterial
            );
            leftLeg.position.set(0.1, -0.2, 0);
            leftLeg.castShadow = true;
            player.add(leftLeg);

            return player;
        }

        const playerModel = createPlayerModel();
        playerModel.visible = false; // Hide local player model
        scene.add(playerModel);

        // Remote players
        const remotePlayers = {};

        function createNameLabel(name) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;

            context.fillStyle = 'rgba(0, 0, 0, 0.5)';
            context.fillRect(0, 0, 256, 64);

            context.font = 'bold 32px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(name, 128, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(2, 0.5, 1);
            sprite.position.y = 1.5;
            return sprite;
        }

        function addRemotePlayer(id, data) {
            const player = createPlayerModel();
            player.position.set(data.x, data.y, data.z);
            player.rotation.y = data.rotation || 0;

            if (data.name) {
                const label = createNameLabel(data.name);
                player.add(label);
            }

            scene.add(player);
            remotePlayers[id] = player;
        }

        function removeRemotePlayer(id) {
            if (remotePlayers[id]) {
                scene.remove(remotePlayers[id]);
                delete remotePlayers[id];
            }
        }

        function updateRemotePlayer(id, data) {
            if (remotePlayers[id]) {
                remotePlayers[id].position.set(data.x, data.y, data.z);
                remotePlayers[id].rotation.y = data.rotation || 0;
            }
        }

        // Socket events
        socket.on('currentPlayers', (players) => {
            Object.keys(players).forEach(id => {
                if (id !== socket.id) {
                    addRemotePlayer(id, players[id]);
                }
            });
        });

        socket.on('newPlayer', (data) => {
            addRemotePlayer(data.id, data);
        });

        socket.on('playerMoved', (data) => {
            updateRemotePlayer(data.id, data);
        });

        socket.on('playerDisconnected', (id) => {
            removeRemotePlayer(id);
        });

        socket.on('initialBlocks', (blocks) => {
            blocks.forEach(data => {
                const blockType = data.type || 0;
                const block = new THREE.Mesh(
                    new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                    blockMaterials[blockType]
                );
                block.position.set(data.x, data.y, data.z);
                block.castShadow = true;
                block.receiveShadow = true;
                block.userData.isPlacedBlock = true;
                block.userData.blockType = blockType;
                scene.add(block);
                placedBlocks.push(block);
            });
        });

        socket.on('blockPlaced', (data) => {
            const blockType = data.type || 0;
            const block = new THREE.Mesh(
                new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                blockMaterials[blockType]
            );
            block.position.set(data.x, data.y, data.z);
            block.castShadow = true;
            block.receiveShadow = true;
            block.userData.isPlacedBlock = true;
            block.userData.blockType = blockType;
            scene.add(block);
            placedBlocks.push(block);
        });

        socket.on('blockRemoved', (data) => {
            const index = placedBlocks.findIndex(b =>
                Math.abs(b.position.x - data.x) < 0.1 &&
                Math.abs(b.position.y - data.y) < 0.1 &&
                Math.abs(b.position.z - data.z) < 0.1
            );
            if (index !== -1) {
                scene.remove(placedBlocks[index]);
                placedBlocks.splice(index, 1);
            }
        });

        // Create ground
        function createGround() {
            const groundSize = 50;
            for (let x = -groundSize; x < groundSize; x += 2) {
                for (let z = -groundSize; z < groundSize; z += 2) {
                    const block = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 2, 2),
                        grassMaterial
                    );
                    block.position.set(x, -1, z);
                    block.receiveShadow = true;
                    scene.add(block);
                }
            }
        }

        // Create spawn platform
        function createSpawnPlatform() {
            const platformSize = 12;
            for (let x = -platformSize / 2; x < platformSize / 2; x += 2) {
                for (let z = -platformSize / 2; z < platformSize / 2; z += 2) {
                    const block = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 2, 2),
                        stoneMaterial
                    );
                    block.position.set(x, 0, z);
                    block.castShadow = true;
                    block.receiveShadow = true;
                    scene.add(block);
                }
            }
        }

        // Create portal
        function createPortal() {
            // Portal frame
            const framePositions = [
                [-6, 2, -2], [-6, 2, 0], [-6, 2, 2], // Left column
                [6, 2, -2], [6, 2, 0], [6, 2, 2],    // Right column
                [-4, 4, -2], [-2, 4, -2], [0, 4, -2], [2, 4, -2], [4, 4, -2] // Top
            ];

            framePositions.forEach(pos => {
                const block = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2, 2),
                    stoneMaterial
                );
                block.position.set(pos[0], pos[1], pos[2]);
                block.castShadow = true;
                scene.add(block);
            });

            // Portal glow effect
            const portalGeo = new THREE.PlaneGeometry(10, 6);
            const portal = new THREE.Mesh(portalGeo, glowMaterial);
            portal.position.set(0, 2, -2);
            portal.userData.isPortal = true;
            scene.add(portal);

            return portal;
        }

        // Create Message Board Screen
        let messageBoardTexture;
        let messageBoardContext;

        function createMessageBoard() {
            // Create canvas for texture
            const boardCanvas = document.createElement('canvas');
            boardCanvas.width = 512;
            boardCanvas.height = 256;
            messageBoardContext = boardCanvas.getContext('2d');

            // Initial draw
            drawMessageBoard([]);

            messageBoardTexture = new THREE.CanvasTexture(boardCanvas);
            messageBoardTexture.minFilter = THREE.LinearFilter;

            // Screen mesh
            const screenGeo = new THREE.PlaneGeometry(8, 4);
            const screenMat = new THREE.MeshBasicMaterial({
                map: messageBoardTexture,
                side: THREE.DoubleSide
            });

            const screen = new THREE.Mesh(screenGeo, screenMat);
            screen.position.set(0, 7, -2); // Above portal
            screen.rotation.y = 0; // Facing forward? Portal is at z=-2, facing ??
            // Portal frame positions imply it's facing Z axis.
            // Let's check portal construction.
            // Portal is at z=-2. Frame is around it.
            // So screen should be slightly in front or same plane.

            scene.add(screen);
            return screen;
        }

        function drawMessageBoard(messages) {
            const ctx = messageBoardContext;
            if (!ctx) return;

            // Background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 512, 256);

            // Border
            ctx.strokeStyle = '#55ff55';
            ctx.lineWidth = 10;
            ctx.strokeRect(0, 0, 512, 256);

            // Header
            ctx.fillStyle = '#55ff55';
            ctx.font = 'bold 30px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('LOBBY MESSAGES', 256, 40);

            // Messages
            ctx.fillStyle = '#ffffff';
            ctx.font = '20px Courier New';
            ctx.textAlign = 'left';

            messages.slice(-6).forEach((msg, i) => {
                const text = `${msg.author}: ${msg.text}`;
                ctx.fillText(text, 20, 80 + (i * 30));
            });

            if (messageBoardTexture) messageBoardTexture.needsUpdate = true;
        }

        // Create decorative blocks
        function createDecoration() {
            // Trees
            const treePositions = [
                [15, 0, 15], [-15, 0, 15], [15, 0, -15], [-15, 0, -15]
            ];

            treePositions.forEach(pos => {
                // Trunk
                for (let y = 1; y <= 5; y += 2) {
                    const trunk = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 2, 2),
                        woodMaterial
                    );
                    trunk.position.set(pos[0], y, pos[2]);
                    trunk.castShadow = true;
                    scene.add(trunk);
                }

                // Leaves
                for (let x = -2; x <= 2; x += 2) {
                    for (let z = -2; z <= 2; z += 2) {
                        for (let y = 0; y <= 2; y += 2) {
                            const leaves = new THREE.Mesh(
                                new THREE.BoxGeometry(2, 2, 2),
                                new THREE.MeshLambertMaterial({ color: 0x228b22 })
                            );
                            leaves.position.set(pos[0] + x, 7 + y, pos[2] + z);
                            leaves.castShadow = true;
                            scene.add(leaves);
                        }
                    }
                }
            });
        }

        // Build world
        createGround();
        createSpawnPlatform();
        const portal = createPortal();
        createMessageBoard();
        createDecoration();

        // Raycaster for block placement
        const raycaster = new THREE.Raycaster();
        raycaster.far = 10;
        let highlightedBlock = null;

        // Create highlight box
        const highlightGeometry = new THREE.BoxGeometry(2.05, 2.05, 2.05);
        const highlightMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3,
            wireframe: false
        });
        const highlightBox = new THREE.Mesh(highlightGeometry, highlightMaterial);
        highlightBox.visible = false;
        scene.add(highlightBox);

        // Player movement
        const moveSpeed = 0.15;
        const jumpSpeed = 0.3;
        let velocity = { x: 0, y: 0, z: 0 };
        const keys = {};
        let isGrounded = false;
        let isPointerLocked = false;

        // Camera view modes: 0 = first-person, 1 = third-person back, 2 = third-person front
        let cameraView = 0;
        const cameraDistance = 5;

        camera.position.set(0, 3, 15);
        camera.rotation.order = 'YXZ';

        // Mouse controls
        let pitch = 0;
        let yaw = 0;

        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked) return;

            yaw -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
        });

        // Pointer lock and Join Logic
        const startScreen = document.getElementById('click-to-start');
        const nameInput = document.getElementById('player-name-input');
        const joinBtn = document.getElementById('start-btn');
        const errorMsg = document.getElementById('join-error');
        let isJoined = false;
        let myPlayerName = "";

        joinBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent pointer lock immediately
            const name = nameInput.value.trim();
            if (name) {
                myPlayerName = name;
                socket.emit('joinGame', name);
            } else {
                errorMsg.textContent = "Please enter a name";
                errorMsg.style.display = 'block';
            }
        });

        socket.on('joinSuccess', (data) => {
            isJoined = true;
            startScreen.style.display = 'none';
            renderer.domElement.requestPointerLock();
        });

        socket.on('joinError', (msg) => {
            errorMsg.textContent = msg;
            errorMsg.style.display = 'block';
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
            if (!isPointerLocked && isJoined) {
                // Show pause menu or similar? For now just show start screen again but different text
                startScreen.style.display = 'flex';
                startScreen.innerHTML = '<div>Click to Resume</div>';
                startScreen.onclick = () => renderer.domElement.requestPointerLock();
            } else if (isPointerLocked) {
                startScreen.style.display = 'none';
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            if (e.key === ' ' && isGrounded) {
                velocity.y = jumpSpeed;
                isGrounded = false;
            }

            // Number keys for block selection (1-9, 0)
            if (e.key >= '1' && e.key <= '9') {
                selectedBlockType = parseInt(e.key) - 1;
                updateHotbarDisplay();
            } else if (e.key === '0') {
                selectedBlockType = 9;
                updateHotbarDisplay();
            }

            // Toggle camera view with T
            if (e.key.toLowerCase() === 't') {
                cameraView = (cameraView + 1) % 3;

                if (cameraView === 0) {
                    // First person
                    playerModel.visible = false;
                } else {
                    // Third person
                    playerModel.visible = true;
                }
            }

            // Clear all blocks with C
            if (e.key.toLowerCase() === 'c') {
                // Not implemented for multiplayer yet or admin only
                // clearAllBlocks(); 
            }

            // Interact with E
            if (e.key.toLowerCase() === 'e') {
                if (nearPortal && isJoined && !isMessageInputOpen) {
                    openMessageInput();
                }
            }

            // Close message input with ESC
            if (e.key === 'Escape' && isMessageInputOpen) {
                closeMessageInput();
            }

            // Toggle Debug Mode with G
            if (e.key.toLowerCase() === 'g') {
                toggleDebugMode();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mouse click for block interaction
        document.addEventListener('mousedown', (e) => {
            if (!isPointerLocked) return;

            if (e.button === 0) { // Left click: Place block
                if (highlightBox.visible) {
                    const x = highlightBox.position.x;
                    const y = highlightBox.position.y;
                    const z = highlightBox.position.z;

                    // Check if player is inside the block
                    const playerPos = camera.position.clone();
                    if (cameraView !== 0) playerPos.copy(playerModel.position);

                    const dx = Math.abs(playerPos.x - x);
                    const dy = Math.abs(playerPos.y - y);
                    const dz = Math.abs(playerPos.z - z);

                    if (dx < 1.5 && dy < 2 && dz < 1.5) return; // Don't place inside player

                    const blockData = {
                        x: x,
                        y: y,
                        z: z,
                        type: selectedBlockType
                    };

                    // Optimistic update
                    const block = new THREE.Mesh(
                        new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                        blockMaterials[selectedBlockType]
                    );
                    block.position.set(x, y, z);
                    block.castShadow = true;
                    block.receiveShadow = true;
                    block.userData.isPlacedBlock = true;
                    block.userData.blockType = selectedBlockType;
                    scene.add(block);
                    placedBlocks.push(block);

                    socket.emit('blockPlace', blockData);
                    showSaveIndicator();
                    logToUI(`Placed block at ${x}, ${y}, ${z}`);
                }
            } else if (e.button === 2) { // Right click: Remove block
                if (highlightedBlock && highlightedBlock.userData.isPlacedBlock) {
                    const x = highlightedBlock.position.x;
                    const y = highlightedBlock.position.y;
                    const z = highlightedBlock.position.z;

                    // Optimistic update
                    scene.remove(highlightedBlock);
                    const index = placedBlocks.indexOf(highlightedBlock);
                    if (index > -1) placedBlocks.splice(index, 1);

                    socket.emit('blockRemove', { x, y, z });
                    showSaveIndicator(); // Maybe different color for remove?
                    logToUI(`Removed block at ${x}, ${y}, ${z}`);
                }
            }
        });

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Block collision detection
        function checkBlockCollision(newPos) {
            const playerRadius = 0.5;
            const playerHeight = 1.8;

            for (const block of placedBlocks) {
                const blockPos = block.position;
                const dx = Math.abs(newPos.x - blockPos.x);
                const dy = Math.abs(newPos.y - blockPos.y);
                const dz = Math.abs(newPos.z - blockPos.z);

                // Check horizontal collision
                if (dx < blockSize / 2 + playerRadius &&
                    dz < blockSize / 2 + playerRadius &&
                    dy < blockSize / 2 + playerHeight / 2) {
                    return block;
                }
            }
            return null;
        }

        // Check if player can stand on block
        function checkGroundBlocks() {
            const feetPos = camera.position.clone();
            feetPos.y -= 1.8; // Player height

            for (const block of placedBlocks) {
                const blockTop = block.position.y + blockSize / 2;
                const distXZ = Math.sqrt(
                    Math.pow(feetPos.x - block.position.x, 2) +
                    Math.pow(feetPos.z - block.position.z, 2)
                );

                if (distXZ < blockSize / 2 + 0.3 &&
                    Math.abs(feetPos.y - blockTop) < 0.3) {
                    return blockTop;
                }
            }
            return null;
        }

        // Check if near portal
        let nearPortal = false;

        function checkPortalProximity() {
            const distance = camera.position.distanceTo(portal.position);
            nearPortal = distance < 8;
            document.getElementById('interaction-prompt').style.display = nearPortal ? 'block' : 'none';
        }

        // Store player position for physics
        const playerPosition = new THREE.Vector3(0, 3, 15);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Movement logic
            if (isPointerLocked || (isJoined && isTouchDevice)) {

                // Apply look vector (Mobile)
                if (isTouchDevice) {
                    const lookSpeed = 0.05;
                    yaw -= lookVector.x * lookSpeed;
                    pitch -= lookVector.y * lookSpeed;
                    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

                    camera.rotation.y = yaw;
                    camera.rotation.x = pitch;
                }

                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

                const moveDir = new THREE.Vector3(0, 0, 0);

                if (keys['w']) moveDir.add(forward);
                if (keys['s']) moveDir.sub(forward);
                if (keys['d']) moveDir.add(right);
                if (keys['a']) moveDir.sub(right);

                // Joystick Input
                if (joystickVector.y < -0.1) moveDir.add(forward.clone().multiplyScalar(-joystickVector.y));
                if (joystickVector.y > 0.1) moveDir.sub(forward.clone().multiplyScalar(joystickVector.y));
                if (joystickVector.x > 0.1) moveDir.add(right.clone().multiplyScalar(joystickVector.x));
                if (joystickVector.x < -0.1) moveDir.sub(right.clone().multiplyScalar(-joystickVector.x));

                if (moveDir.length() > 0) {
                    moveDir.normalize().multiplyScalar(moveSpeed);
                    velocity.x = moveDir.x;
                    velocity.z = moveDir.z;
                } else {
                    velocity.x = 0;
                    velocity.z = 0;
                }

                // Gravity
                if (!isGrounded) {
                    velocity.y -= 0.02;
                }

                // Apply velocity to temp position
                const movePos = playerPosition.clone();
                movePos.x += velocity.x;
                movePos.z += velocity.z;

                // Check collision with placed blocks (horizontal)
                const collision = checkBlockCollision(movePos);
                if (!collision) {
                    playerPosition.x = movePos.x;
                    playerPosition.z = movePos.z;
                } else {
                    velocity.x = 0;
                    velocity.z = 0;
                }

                // Apply vertical velocity
                playerPosition.y += velocity.y;

                // Check if standing on a placed block
                // We need to temporarily update camera position for checkGroundBlocks to work as it uses camera.position
                // Or better, update checkGroundBlocks to accept a position. 
                // Since I can't easily change checkGroundBlocks signature without another edit, 
                // I will temporarily set camera.position to playerPosition for the check.
                const originalCamPos = camera.position.clone();
                camera.position.copy(playerPosition);

                const groundBlock = checkGroundBlocks();
                camera.position.copy(originalCamPos); // Restore

                if (groundBlock !== null && velocity.y <= 0) {
                    playerPosition.y = groundBlock + 1.8; // Player height offset
                    velocity.y = 0;
                    isGrounded = true;
                } else if (playerPosition.y <= 3) { // Ground level
                    playerPosition.y = 3;
                    velocity.y = 0;
                    isGrounded = true;
                } else if (velocity.y < 0) {
                    isGrounded = false;
                }

                // Update player model position
                playerModel.position.set(playerPosition.x, playerPosition.y - 1.5, playerPosition.z);
                playerModel.rotation.y = yaw;

                // Update camera position based on view mode
                if (cameraView === 0) { // First person
                    camera.position.copy(playerPosition);
                } else if (cameraView === 1) { // Third person back
                    const offset = new THREE.Vector3(0, 2, cameraDistance).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                    camera.position.copy(playerPosition).add(offset);
                    camera.lookAt(playerPosition);
                } else if (cameraView === 2) { // Third person front
                    const offset = new THREE.Vector3(0, 2, -cameraDistance).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                    camera.position.copy(playerPosition).add(offset);
                    camera.lookAt(playerPosition);
                }

                checkPortalProximity();

                // Send position update to server
                socket.emit('playerMove', {
                    x: playerModel.position.x,
                    y: playerModel.position.y,
                    z: playerModel.position.z,
                    rotation: yaw,
                    name: myPlayerName // Send name
                });

                // Update coordinates display
                document.getElementById('coord-x').textContent = Math.round(playerPosition.x);
                document.getElementById('coord-y').textContent = Math.round(playerPosition.y);
                document.getElementById('coord-z').textContent = Math.round(playerPosition.z);
            }

            // Raycasting for block interaction
            const rayOrigin = cameraView === 0 ? camera.position.clone() : playerPosition.clone().add(new THREE.Vector3(0, 0.5, 0));
            // In third person, raycast from player head roughly? 
            // Actually, standard behavior is usually raycast from camera even in third person, 
            // but for block placement it might be weird. 
            // Let's stick to camera for raycasting as it's what the user sees.

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            const intersects = raycaster.intersectObjects(scene.children);

            highlightBox.visible = false;
            highlightedBlock = null;

            for (let i = 0; i < intersects.length; i++) {
                // Ignore player model and transparent objects like highlight box
                if (intersects[i].object === highlightBox ||
                    intersects[i].object.parent === playerModel ||
                    intersects[i].object.userData.isPlayer ||
                    intersects[i].object.userData.isPortal) continue; // Also ignore portal

                const intersect = intersects[i];

                if (intersect.distance < 8) {
                    // Highlight block we're looking at
                    highlightedBlock = intersect.object;

                    // Calculate position for new block
                    const normal = intersect.face.normal;
                    const pos = intersect.object.position.clone().add(normal.multiplyScalar(blockSize));

                    // Snap to grid
                    pos.x = Math.round(pos.x / 2) * 2;
                    pos.y = Math.round(pos.y / 2) * 2;
                    pos.z = Math.round(pos.z / 2) * 2;

                    highlightBox.position.copy(pos);
                    highlightBox.visible = true;
                    break;
                }
            }

            renderer.render(scene, camera);
        }

        // Debug Mode Logic
        let debugMode = false;
        const debugIndicator = document.getElementById('debug-mode-indicator');

        function toggleDebugMode() {
            debugMode = !debugMode;

            // Toggle UI elements
            debugLog.style.display = debugMode ? 'flex' : 'none';
            debugIndicator.style.display = debugMode ? 'block' : 'none';

            // Optional: Toggle other debug visuals like block indicator or coordinates if desired
            // For now, just the log and indicator as requested

            logToUI(`Debug Mode: ${debugMode ? 'ON' : 'OFF'}`);
        }

        // Initialize debug mode state (start OFF)
        // We need to hide debugLog initially since it's defined in CSS as flex
        // But wait, the CSS says display: flex. So it's ON by default?
        // Let's set it to match debugMode initial state.


        // Debug Logging
        const debugLog = document.getElementById('debug-log');
        function logToUI(msg) {
            const entry = document.createElement('div');
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            debugLog.insertBefore(entry, debugLog.firstChild);
            // Keep only last 20 logs
            if (debugLog.children.length > 20) {
                debugLog.removeChild(debugLog.lastChild);
            }
            console.log(msg);
        }

        // Save Indicator
        const saveIndicator = document.getElementById('save-indicator');
        function showSaveIndicator() {
            saveIndicator.classList.add('show');
            setTimeout(() => {
                saveIndicator.classList.remove('show');
            }, 1000);
        }

        // Real-time Stats Logic
        const statusSpan = document.querySelector('.status-online');
        const playerCountSpan = document.getElementById('player-count');
        const pingSpan = document.getElementById('ping');

        // Update player count display
        function updatePlayerCount() {
            // Count remote players + 1 (self)
            const count = Object.keys(remotePlayers).length + (isJoined ? 1 : 0);
            playerCountSpan.textContent = `${count}/100`;
        }

        // Socket connection status
        socket.on('connect', () => {
            statusSpan.textContent = '‚óè Online';
            statusSpan.className = 'status-online';
            statusSpan.style.color = '#55ff55';
            logToUI('Connected to server');
        });

        socket.on('connect_error', (err) => {
            statusSpan.textContent = '‚óè Error';
            statusSpan.className = 'status-offline';
            statusSpan.style.color = '#ff5555';
            logToUI('Connection error: ' + err.message);
        });

        socket.on('disconnect', () => {
            statusSpan.textContent = '‚óè Offline';
            statusSpan.className = 'status-offline';
            statusSpan.style.color = '#ff5555';
            pingSpan.textContent = '- ms';
            logToUI('Disconnected from server');
        });

        socket.on('initialBlocks', (blocks) => {
            logToUI(`Received ${blocks.length} initial blocks`);
            // ... existing block loading logic is inside the socket.on handler in the main script ...
            // Wait, the main script logic for initialBlocks is separate. 
            // We need to make sure we don't duplicate listeners or miss them.
            // The previous replace_file_content removed the main script block? 
            // No, I need to check where the main logic is.
        });

        // Hook into existing player events to update count
        // We need to update count whenever players change.

        socket.on('currentPlayers', (players) => {
            setTimeout(updatePlayerCount, 100);
            logToUI(`Synced ${Object.keys(players).length} players`);
        });

        socket.on('newPlayer', (data) => {
            setTimeout(updatePlayerCount, 100);
            logToUI(`Player joined: ${data.name || data.id}`);
        });

        socket.on('playerDisconnected', () => {
            setTimeout(updatePlayerCount, 100);
            logToUI('Player disconnected');
        });

        socket.on('joinSuccess', () => {
            setTimeout(updatePlayerCount, 100);
            logToUI('Joined game successfully');
        });

        socket.on('blockPlaced', (data) => {
            logToUI(`Remote block placed at ${data.x}, ${data.y}, ${data.z}`);
        });

        socket.on('blockRemoved', (data) => {
            logToUI(`Remote block removed at ${data.x}, ${data.y}, ${data.z}`);
        });

        socket.on('blockSaveSuccess', (data) => {
            logToUI(`‚úÖ Server confirmed save at ${data.x}, ${data.y}, ${data.z}`);
        });

        socket.on('blockSaveError', (msg) => {
            logToUI(`‚ùå Save failed: ${msg}`);
            alert(`Failed to save block: ${msg}`);
        });

        socket.on('chatUpdate', (history) => {
            drawMessageBoard(history);
        });

        // Message Input Logic
        const messageInputContainer = document.getElementById('message-input-container');
        const messageInput = document.getElementById('message-input');
        let isMessageInputOpen = false;

        function openMessageInput() {
            isMessageInputOpen = true;
            document.exitPointerLock();
            messageInputContainer.style.display = 'block';
            messageInput.value = '';
            messageInput.focus();
        }

        function closeMessageInput() {
            isMessageInputOpen = false;
            messageInputContainer.style.display = 'none';
            renderer.domElement.requestPointerLock();
        }

        messageInput.addEventListener('keydown', (e) => {
            e.stopPropagation(); // Prevent game controls
            if (e.key === 'Enter') {
                const text = messageInput.value.trim();
                if (text) {
                    socket.emit('chatMessage', {
                        text: text,
                        author: myPlayerName
                    });
                    closeMessageInput();
                }
            }
        });

        // Ping measurement
        setInterval(() => {
            if (socket.connected) {
                const start = Date.now();
                socket.emit('ping');
                socket.once('pong', () => {
                    const latency = Date.now() - start;
                    pingSpan.textContent = `${latency}ms`;
                });
            }
        }, 2000);

        // Initialize
        document.getElementById('debug-log').style.display = 'none'; // Start hidden

        // Mobile Controls Logic
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const mobileControls = document.getElementById('mobile-controls');
        const joystickZone = document.getElementById('joystick-zone');
        const joystickKnob = document.getElementById('joystick-knob');
        const jumpBtn = document.getElementById('jump-btn');
        const actionBtn = document.getElementById('action-btn');
        const controlsInfo = document.getElementById('controls');

        let joystickVector = { x: 0, y: 0 };
        let lookVector = { x: 0, y: 0 };

        if (isTouchDevice) {
            mobileControls.style.display = 'block';
            controlsInfo.style.display = 'none'; // Hide keyboard instructions

            // Left Joystick (Move)
            const joystickRadius = 60; // Half of base width
            const knobRadius = 25;
            let joystickCenter = { x: 0, y: 0 };

            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                const rect = joystickZone.getBoundingClientRect();
                joystickCenter = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
                updateJoystick(touch);
            }, { passive: false });

            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                updateJoystick(touch);
            }, { passive: false });

            joystickZone.addEventListener('touchend', (e) => {
                e.preventDefault();
                resetJoystick();
            }, { passive: false });

            function updateJoystick(touch) {
                const dx = touch.clientX - joystickCenter.x;
                const dy = touch.clientY - joystickCenter.y;
                const distance = Math.min(Math.sqrt(dx * dx + dy * dy), joystickRadius);
                const angle = Math.atan2(dy, dx);

                const knobX = Math.cos(angle) * distance;
                const knobY = Math.sin(angle) * distance;

                joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

                // Normalize vector (-1 to 1)
                joystickVector.x = knobX / joystickRadius;
                joystickVector.y = knobY / joystickRadius;
            }

            function resetJoystick() {
                joystickKnob.style.transform = 'translate(-50%, -50%)';
                joystickVector = { x: 0, y: 0 };
            }

            // Right Joystick (Look)
            const lookZone = document.getElementById('look-joystick-zone');
            const lookKnob = document.getElementById('look-joystick-knob');
            let lookCenter = { x: 0, y: 0 };

            lookZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                const rect = lookZone.getBoundingClientRect();
                lookCenter = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
                updateLookJoystick(touch);
            }, { passive: false });

            lookZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                updateLookJoystick(touch);
            }, { passive: false });

            lookZone.addEventListener('touchend', (e) => {
                e.preventDefault();
                resetLookJoystick();
            }, { passive: false });

            function updateLookJoystick(touch) {
                const dx = touch.clientX - lookCenter.x;
                const dy = touch.clientY - lookCenter.y;
                const distance = Math.min(Math.sqrt(dx * dx + dy * dy), joystickRadius);
                const angle = Math.atan2(dy, dx);

                const knobX = Math.cos(angle) * distance;
                const knobY = Math.sin(angle) * distance;

                lookKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

                lookVector.x = knobX / joystickRadius;
                lookVector.y = knobY / joystickRadius;
            }

            function resetLookJoystick() {
                lookKnob.style.transform = 'translate(-50%, -50%)';
                lookVector = { x: 0, y: 0 };
            }

            // Jump Button
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (isGrounded) {
                    velocity.y = jumpSpeed;
                    isGrounded = false;
                }
            }, { passive: false });

            // Action Button (Place Block)
            actionBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                // Simulate left click
                const event = new MouseEvent('mousedown', {
                    button: 0,
                    bubbles: true,
                    cancelable: true
                });
                document.dispatchEvent(event);
            }, { passive: false });
        }

        animate();
    </script>
</body>

</html>